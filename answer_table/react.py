
react = {
	"i": {
		"ques": "Что такое React?",
		"result": 
'''
	React - это библиотека JavaScript, которая используется
	для создания пользовательских интерфейсов. Она была 
	создана компанией Facebook и стала очень популярной 
	среди разработчиков. React позволяет создавать компоненты
	интерфейса, которые могут быть использованы многократно.
	Это ускоряет процесс разработки и делает код более 
	организованным.
'''
	},

	"h": {
		"ques": "Особенности React",
		"result": 
'''
	-React использует виртуальное DOM-дерево для оптимизации
	 производительности.

	-React позволяет создавать повторно используемые компоненты,
	 что упрощает разработку и улучшает читаемость кода.

	-React поддерживает состояние и пропсы для управления
	 данными.

	-React имеет встроенный инструмент для тестирования - Jest.

	-React интегрируется с другими инструментами и фреймворками,
	 такими как Redux, React Router и Material-UI.

	-React может использоваться как на стороне клиента 
	(в браузере), так и на стороне сервера (с помощью React 
	Server Side Rendering).
'''
	},

	"sr": {
		"ques": "Что такое серверный рендеринг (Server-Side Rendering)",
		"result": 
'''
	Серверный рендеринг (SSR) – это техника, при которой сервер создает готовую к 
	отображению веб-страницу и отправляет ее пользователю. Этот подход отличается 
	от традиционного, при котором сервер отправляет только исходный код HTML, а 
	готовый вид страница приобретает после обработки клиентским браузером.

	Основная цель серверного рендеринга – улучшение скорости загрузки страниц и 
	повышение позиций в поисковом ранжировании. Используя SSR, сервер подготавливает 
	страницу полностью, включая динамическое содержимое. В результате пользователь 
	получает готовую к просмотру страницу, без необходимости выполнения дополнительных 
	запросов к серверу.
	
	Применение SSR особенно полезно для приложений, где много контента генерируется 
	с помощью JavaScript, так как поисковые системы не могут индексировать такой контент. 
	Используя серверный рендеринг, поисковики могут легко увидеть и проиндексировать 
	все содержимое страницы.

	Помимо React, SSR поддерживается многими современными фреймворками, например 
	Next.js, Nuxt.js и Meteor.js.
'''
	},

	"pr": {
		"ques": "Перечислите преимущества серверного рендеринга",
		"result": 
'''
	Серверный рендеринг имеет несколько весомых преимуществ:

	- Улучшение времени загрузки – серверный рендеринг позволяет серверу отправить 
	пользователю полностью готовую к отображению HTML-страничку, уменьшая тем самым 
	объем обработки на стороне клиента и ускоряя загрузку страницы.

	- Улучшение видимости в поисковых системах – поисковые роботы могут легко 
	просматривать и индексировать содержание страниц, обработанных на стороне 
	сервера, что приводит к улучшению видимости в результатах поиска.

	- Обеспечение доступности – серверный рендеринг обеспечивает доступность 
	контента для пользователей с отключенным JavaScript, гарантируя надежное и 
	полное отображение всех страниц приложения.

	- Повышение производительности в условиях низкой скорости интернета –серверный 
	рендеринг уменьшает объем данных, получаемых пользователем.

	- Несмотря на все преимущества SSR, важно отметить, что по сравнению с методами 
	рендеринга на стороне клиента он может создавать большую нагрузку на сервер и 
	усложнять обслуживание. Необходимо тщательно учитывать такие факторы, как 
	кэширование, масштабируемость и оптимизация производительности рендеринга на 
	стороне сервера.
'''
	},

	"li": {
		"ques": "Что такое линтеры",
		"result": 
'''
	Линтеры – это инструменты для проверки исходного кода на наличие потенциальных 
	ошибок, недочетов, стилистических несоответствий и проблем с сопровождением. Они 
	помогают соблюдать стандарты кодирования, обеспечивают качество и согласованность 
	кода во всей кодовой базе.

	Линтеры работают путем сканирования исходного кода и сравнения его с набором 
	предопределенных правил или рекомендаций. Эти правила могут включать соглашения 
	по синтаксису и форматированию, лучшие практики, потенциальные ошибки и запахи 
	кода. При обнаружении нарушения правил линтер выдает предупреждение или ошибку, 
	выделяя конкретную строку или строки кода, требующие внимания.
	

	Использование линтеров дает ряд преимуществ:

	- Качество кода. Линтеры помогают выявлять и предотвращать потенциальные ошибки, 
	запахи кода и антипаттерны, что приводит к повышению качества кода.

	- Согласованность. Линтеры обеспечивают соблюдение соглашений о кодировании и 
	стилевых рекомендаций, гарантируя согласованное форматирование и структуру кода 
	во всей кодовой базе, даже если над одним проектом работают несколько разработчиков.

	- Удобство сопровождения. Выявляя проблемы на ранних стадиях и пропагандируя 
	передовые методы кодирования, линтеры способствуют повышению удобства сопровождения 
	кода, облегчая понимание, модификацию и расширение кодовой базы.

	- Эффективность. Линтеры позволяют сэкономить время разработчиков, автоматизируя 
	процессы рецензирования кода и выявляя типичные ошибки до того, как они могут привести 
	к проблемам в процессе разработки или в производстве.

	- Среди популярных линтеров можно назвать ESLint для JavaScript и Stylelint 
	для CSS и Sass.
'''
	},

	"ah": {
		"ques": "Какие архитектурные решения для React вы знаете",
		"result": 
'''
	Существует несколько архитектурных решений и паттернов для построения 
	React-проектов. К числу популярных относятся:

	- MVC (Model-View-Controller). Это традиционный архитектурный паттерн, 
	разделяющий приложение на три основных компонента – модель, представление 
	и контроллер. React может использоваться в слое View для визуализации 
	пользовательского интерфейса, в то время как для слоев Model и Controller
	могут применяться другие библиотеки или фреймворки.

	- Flux. Эта архитектура была создана разработчиками Facebook* специально для 
	приложений React. Он основан на однонаправленной передаче данных, что упрощает 
	понимание кода и отладку компонентов приложения.

	- Atomic Design. Это универсальная методология проектирования, которая 
	разделяет пользовательский интерфейс на более мелкие самодостаточные 
	компоненты многократного использования. Такие компоненты удобно комбинировать 
	для создания более сложных пользовательских интерфейсов.

	- Паттерн «Контейнер и компонент». Этот паттерн отделяет представление 
	(компонент) от логики и управления состоянием (контейнер). Компоненты 
	отвечают за визуализацию пользовательского интерфейса, а контейнеры – за 
	бизнес-логику и управление состоянием.

	- Feature-Sliced Design. Это современный архитектурный подход, используемый 
	для организации и структурирования React-приложений. Он направлен на 
	решение проблем масштабируемости, сопровождения и повторного использования 
	путем разделения кодовой базы приложения на основные функциональные модули.
'''
	},

	"tt": {
		"ques": "Как выполняется валидация данных в React-приложении",
		"result": 
'''
	Валидацию данных можно реализовать несколькими способами:

	- PropTypes – это встроенный в React механизм, который позволяет определить 
	тип данных для каждого реквизита компонента. Если тип данных не соответствует 
	ожидаемому, PropTypes выводит предупреждение в консоль браузера.

	- Пользовательские функции проверки – разработчик может написать свои функции 
	для проверки правильности данных. Такие функции можно вызывать внутри компонента 
	и использовать их для отображения сообщений об ошибках или изменения состояния 
	компонента при обнаружении некорректных данных.

	- Сторонние библиотеки – существуют сторонние библиотеки (например yup, joi, zod), 
	которые предоставляют более мощные и гибкие инструменты для проверки данных. Они 
	также обычно предоставляют более удобные способы отображения ошибок.
'''
	},

	"r": {
		"ques": "Что такое Virtual DOM",
		"result": 
'''
	-Virtual DOM (Virtual Document Object Model) - это 
	виртуальный аналог настоящего DOM-дерева, используемый в
	React для улучшения производительности приложения. 
	Виртуальный DOM позволяет быстро и эффективно обновить 
	пользовательский интерфейс без необходимости полной 
	перерисовки всей страницы.

	-Работа Virtual DOM основана на том, что при изменении
	данных в приложении React создаёт новый виртуальный DOM,
	сравнивает его с предыдущим виртуальным DOM и находит только
	те элементы, которые реально были изменены. После этого 
	React обновляет настоящий DOM только для изменённых элементов,
	что существенно ускоряет процесс обновления 
	пользовательского интерфейса.
'''
	},

	"k": {
		"ques": "Атрибут key при рендере?",
		"result": 
'''
	Атрибут key используется React при определении порядка 
	рендеринга элементов в списке. Если у элементов списка 
	нет уникального ключа, React не сможет определить порядок 
	рендеринга и может возникнуть ошибка или неожиданные результаты.

	При использовании ключей React может определить порядок 
	рендеринга, гарантируя тем самым корректную работу вашего 
	приложения. Ключи должны быть уникальными для каждого 
	элемента списка, и рекомендуется использовать значения, 
	которые однозначно идентифицируют каждый элемент.
'''
	},

	"p": {
		"ques": "PureComponent",
		"result": 
'''
	Класс React.PureComponent позволяет создавать на его 
	основе компоненты также, как и класс React.Component,
	однако они имеют одно важное различие.

	В React.PureComponent реализован метод жизненного цикла
	shouldComponentUpdate(), отвечающий за проверку, нужно 
	ли производить перерисовку компонента или нет. Он производит
	поверхностное сравнение пропов и состояния компонента с 
	предыдущими, чтобы понять, изменились ли они, и перерисовка
	происходит только в случае нахождения различий.

	В React.Component перерисовка происходит всегда, так как
	подобная проверка отсутствует. Однако при желании 
	ее может реализовать программист.
'''
	},

	"c": {
		"ques": "Higher-Order Component / HOC",
		"result": 
'''
	Компонент высшего порядка - это функция, которая принимает 
	компонент в качестве аргумента и возвращает другой компонент.
	HOC позволяет расширять функциональность компонента без изменения
	его исходного кода. Например, можно создать HOC, который добавляет
	авторизацию к компоненту, не изменяя сам компонент.
'''
	},

	"q": {
		"ques": "Жизненный цикл компонентов React",
		"result": 
'''
	1.Инициализация
	2.Монтирование
	3.Обновление
	4.Размонтирование
'''
	},

	"t": {
		"ques": "Что такое Portal",
		"result": 
'''
	Порталы - это способ визуализации элемента в узле DOM, 
	который существует вне иерархии DOM родительского компонента.
	Это полезно для компонентов таких как модальные окна, тултипы, и др

	ReactDOM.createPortal(элемент который, элемент куда) 
	createPortal(children, domNode, key?)

	import { createPortal } from 'react-dom';

	// ...

	<div>
	  	<p>This child is placed in the parent div.</p>
	  		{createPortal(
	    <p>This child is placed in the document body.</p>,
	    document.body
	  )}
	</div>oop.py
'''
	},

	"b": {
		"ques": "Что такое React хуки",
		"result": 
'''
	React Hooks – это механизм, позволяющий использовать состояние
	и некоторые другие возможности React внутри функциональных 
	компонентов, не прибегая к классам. Они были представлены в React
	16.8 и позволяют упростить и улучшить код компонентов.

	С помощью Hooks можно работать с состоянием, использовать эффекты
	(например, обработку жизненного цикла компонента или асинхронные
	операции), а также применять другие функции React. При этом Hooks
	не заменяют полностью классы, а лишь упрощают их использование.
'''
	},

	"j": {
		"ques": "Что Такое JSX?",
		"result": 
'''
	JSX — это язык разметки, который используется для создания 
	пользовательских интерфейсов (UI) на основе HTML. Он является 
	расширением языка JavaScript и позволяет создавать элементы HTML, 
	такие как div, span, input и др., прямо в коде JavaScript. JSX 
	также позволяет определять стили CSS и обрабатывать события 
	JavaScript внутри одного файла.
'''
	},


	"s": {
		"ques": "Разница между состоянием(state) и пропсами(props)?",
		"result": 
'''
	Состояние (state) компонента - это внутренняя переменная, которая
	хранит данные компонента. Состояние изменяется при выполнении 
	определенных действий, например, при нажатии на кнопку.

	Пропсы (props) - это входные данные, которые передаются компоненту 
	от родительского компонента. Пропсы используются для передачи данных 
	между компонентами и не могут быть изменены внутри компонента.

	Основное различие между состоянием и пропсами заключается в том, 
	что состояние изменяется внутри компонента, в то время как пропсы 
	передаются извне и не могут быть изменены.
'''
	},

	"f": {
		"ques": "Что такое React Fiber",
		"result": 
'''
	React Fiber - это новая система рендеринга React, представленная
	в React 16.6, которая предназначена для улучшения производительности
	приложений React. Fiber использует асинхронную модель рендеринга,
	где компоненты могут рендериться параллельно, что позволяет улучшить
	производительность и уменьшить время загрузки страниц.

	Fiber также предоставляет возможность управления приоритетами 
	рендеринга компонентов, что позволяет приложениям React лучше 
	использовать ресурсы браузера и оптимизировать производительность. 
	Кроме того, Fiber поддерживает разделение кода на несколько потоков, 
	что может снизить нагрузку на основной поток и улучшить 
	производительность приложения в целом.
'''
	},

	"y": {
		"ques": "Синтетические события в react",
		"result": 
'''
	Синтетические события в React — это механизм, который позволяет
	компонентам обрабатывать пользовательские события, такие как клики,
	изменения форм и т. д. Это позволяет улучшить производительность
	и гибкость приложения.

	Синтетические события отличаются от обычных тем, что они 
	обрабатываются на уровне компонентов в React, а не на уровне DOM. 
	Это позволяет упростить обработку событий и сделать код более модульным. 
	Кроме того, синтетические события позволяют использовать хуки, что 
	делает код еще более читаемым и удобным для разработки.
'''
	},

	"m": {
		"ques": "Что такое компонент-переключатель (Switching Component)",
		"result": 
'''
	Компонент-переключатель в React используется для отображения или 
	скрытия другого компонента в зависимости от определенного условия. 
	Он принимает условие в качестве параметра и возвращает один из 
	двух компонентов: либо первый компонент, либо второй.
'''
	},

	"d": {
		"ques": "Что такое React DOM",
		"result": 
'''
	React DOM - это библиотека, которая позволяет отображать react 
	компоненты на странице. Она взаимодействует с браузером и рендерит 
	компоненты на страницу. React DOM используется вместе с React, чтобы
	создавать интерактивные и динамические веб-страницы.
'''
	},

	"z": {
		"ques": "Разница между компонентом и контейнером React",
		"result": 
'''
	Компонент - это минимальная функциональная единица приложения React,
	которая может состоять из текста, изображений, форм и других элементов.
	Компоненты используются для создания пользовательского интерфейса приложения.

	Контейнеры - это также компоненты, но они используются для управления 
	состоянием и данными в приложении. Они отвечают за обработку данных, 
	поступающих от пользователей, и отправку их на сервер. Контейнеры также 
	могут управлять состоянием компонентов и обновлять их при изменении данных.

	КОНТЕЙНЕР - ВЫПОЛНЯЕТ БИЗНЕС-ЛОГИКУ(ПОЛУЧЕНИЕ ДАННЫХ И Т.Д) И ПЕРЕДАЕТ ЕЕ В КОМПОНЕНТ
	КОМПОНЕНТ - ВЫПОЛНЯЕТ ОТРИСОВКУ ДАННЫХ

	Ниже приведены некоторые причины, по которым нам требуются контейнерные и 
	презентационные компоненты:
		-Они помогают нам создавать слабосвязанные компоненты.
		-Они помогают нам поддерживать разделение ответственности.
		-Рефакторинг кода становится намного проще.
		-Код становится более организованным и удобным в сопровождении
		-Это значительно упрощает тестирование.
'''
	},

	"n": {
		"ques": "Что такое «опрос» (Polling)",
		"result": 
'''
	Опрос (polling) - это метод, при котором клиент периодически 
	запрашивает сервер на наличие новых данных. В React это можно 
	реализовать с помощью компонента, который будет периодически 
	отправлять запрос на сервер для получения новых данных. Для 
	этого можно использовать библиотеку axios или fetch.

	componentDidUpdate() {
    	setTimeout(this.fetchData, 5000); 
  	}

  	render() {
    	if (this.state.data === null) {
      		return <div>Загрузка...</div>;
      	}
    }
'''
	},


	"n": {
		"ques": "Что такое «опрос» (Polling)",
		"result": 
'''
	Опрос (polling) - это метод, при котором клиент периодически 
	запрашивает сервер на наличие новых данных. В React это можно 
	реализовать с помощью компонента, который будет периодически 
	отправлять запрос на сервер для получения новых данных. Для 
	этого можно использовать библиотеку axios или fetch.

	componentDidUpdate() {
    	setTimeout(this.fetchData, 5000); 
  	}

  	render() {
    	if (this.state.data === null) {
      		return <div>Загрузка...</div>;
      	}
    }
'''
	},

	"u": {
		"ques": "ReactDOMServer",
		"result": 
'''
	ReactDOMServer — это модуль в React, который позволяет 
	работать с HTML на стороне сервера. Он используется для 
	создания и управления HTML-разметкой на сервере, что может 
	быть полезно при создании статических сайтов или при 
	рендеринге React-компонентов на сервере.
'''
	},

	"e": {
		"ques": "Что такое предохранители (Error Boundaries)",
		"result": 
'''
	Предохранители (Error Boundaries) - это специальные компоненты
	в React, которые позволяют обрабатывать ошибки, возникающие
	в дочерних компонентах. Они помогают предотвратить падение
	всего приложения, если один из компонентов выдает ошибку. 
	Предохранители могут показать пользователю уведомление об 
	ошибке или скрыть проблемный компонент
'''
	},

	"2": {
		"ques": "Разница между рендерингом и монтированием",
		"result": 
'''
	-Рендеринг — это процесс преобразования данных компонента в
	HTML-код. В React рендеринг происходит на основе состояния 
	компонента и его пропсов (свойств). В результате рендеринга 
	создается виртуальный DOM (Document Object Model), который 
	представляет собой структуру HTML-элементов.

	-Монтирование — это процесс вставки компонента в DOM. После 
	того, как компонент отрендерен, React вставляет его в DOM. 
	При этом React следит за изменениями состояния компонента 
	и обновляет его отображение в DOM при необходимости.
'''
	},

	"5": {
		"ques": "сhildren",
		"result": 
'''
	Children в React - это элементы, которые передаются в компонент
	в качестве дочерних элементов. Они могут быть любого типа: 
	строки, числа, другие компоненты и т. д. Children используются
	для создания вложенных компонентов и для передачи данных между ними.
'''
	},

	"a": {
		"ques": "Инверсия наследования (Inheritance Inversion)",
		"result": 
'''
	Инверсия наследования в React - это принцип, согласно которому 
	компоненты должны принимать свойства и состояния от своих родителей,
	а не передавать их вниз по дереву компонентов. Это помогает 
	сохранить структуру приложения простой и понятной, а также 
	облегчает изменение и расширение компонентов в будущем
'''
	},

	"ma": {
		"ques": "Чем управляемые компоненты отличаются от неуправляемых",
		"result": 
'''
	Управляемые компоненты – это компоненты, состояние которых контролируется 
	React. Компонент получает свое текущее значение и обновляет его через 
	реквизиты (пропсы). При изменении значения он также запускает функцию 
	обратного вызова. Это означает, что компонент не хранит собственное 
	внутреннее состояние – вместо этого родительский компонент управляет 
	им и передает значение управляемому компоненту.

	Неуправляемые компоненты, напротив, управляют своим состоянием самостоятельно 
	с помощью ссылок или других методов. Они хранят и обновляют свое состояние 
	самостоятельно, не полагаясь на реквизиты или обратные вызовы. Родительский 
	компонент имеет меньший контроль над состоянием неуправляемых компонентов.
'''
	},

	"de": {
		"ques": "Разница между классовым и функциональным компонентами",
		"result": 
'''
	Классовые компоненты предоставляют дополнительные возможности:
	-управление состоянием через this.state
	-методы жизненного цикла(которых нет в функциональных компонентах)
	
	Функциональные компоненты, как правило:
	-проще 
	-используются для более простых задач.
	-функциональные компоненты обычно работают быстрее, чем классовые компоненты, 
	потому что они имеют меньше накладных расходов и не создают экземпляры классов.
'''
	},

	"w": {
		"ques": " Разница между useEffect() и componentDidMount()",
		"result": 
'''
	useEffect в React используется для выполнения кода после 
	монтирования компонента или после изменения его пропов. 
	Он также может использоваться для очистки ресурсов, когда 
	компонент размонтируется. componentDidMount - это метод жизненного
	цикла компонента, который выполняется только один раз после монтирования 
	компонента. Он не может использоваться для очистки ресурсов 
	при размонтировании компонента.
'''
	},

	"hp": {
		"ques": "Преимущества хуков",
		"result": 
'''
	-Хуки в React предоставляют несколько преимуществ:

	-Хуки позволяют использовать состояние и другие функции React в 
	функциональных компоненрах, что делает их более гибкими и простыми в 
	использовании.

	-Хуки улучшают производительность, так как они не создают новые 
	экземпляры классов для каждого рендера компонента.

	-Хуки упрощают код, так как не нужно создавать новый класс для 
	каждого компонента, и можно использовать один и тот же хук для 
	разных компонентов.

	-Хуки делают код более читаемым и понятным, так как каждый хук 
	выполняет одну конкретную задачу.
'''
	},

	"bb": {
		"ques": "Что такое методы жизненного цикла компонента",
		"result": 
'''
	Методы жизненного цикла – это способ подключения к различным этапам жизненного 
	цикла компонента, позволяющий выполнять определенный код в определенное время. 
	
	Вот список основных методов:

	- constructor – первый метод, вызываемый при создании компонента. 
	Он используется для инициализации состояния и привязки обработчиков 
	событий. В функциональных компонентах для аналогичных целей используется 
	хук useState.

	- render – отвечает за рендеринг JSX-разметки и возвращает содержимое, 
	которое будет выведено на экран.

	- componentDidMount – вызывается сразу после рендеринга компонента в DOM. 
	Обычно используется для задач инициализации, таких как вызов API или 
	настройка слушателей событий.

	- componentDidUpdate – вызывается при изменении реквизитов или состояния 
	компонента. Позволяет выполнять побочные эффекты, обновлять компонент 
	на основе изменений или запускать дополнительные вызовы API.

	- componentWillUnmount – вызывается непосредственно перед удалением компонента 
	из DOM. Используется для очистки ресурсов, которые были установлены в 
	componentDidMount, например, для удаления слушателей событий или отмены таймеров.
'''
	},

	"pa": {
		"ques": "Что такое публичный API",
		"result": 
'''
	В контексте индексных файлов под Public API обычно понимается интерфейс 
	или функции, которые открыты и доступны для внешних модулей или компонентов. 
	Вот пример кода индексного файла, представляющего Public API:

	export function greet(name) {
  		return `Hello, ${name}!`;
	}

	export function calculateSum(a, b) {
  		return a + b;
	}

	В данном примере файл index.js выступает в роли публичного API, в котором 
	экспортируются функции greet() и calculateSum(). Доступ к этим функциям 
	может быть получен из других модулей путем их импорта. Другие модули могут 
	импортировать и использовать эти функции как часть своей реализации:

	// main.js

	import { greet, calculateSum } from './index.js';

	console.log(greet('John')); // Hello, John!
	console.log(calculateSum(5, 3)); // 8

	Экспортируя определенные функции из индексного файла, мы определяем публичный 
	API модуля, позволяя другим модулям использовать эти функции.
'''
	},

	"l": {
		"ques": "Lifting State Up",
		"result": 
'''
	Поднятие состояния вверх (lifting state up) – это принцип 
	организации структуры компонента в React, при котором состояние 
	выносится на уровень ближайшего родительского компонента, 
	который владеет данными, необходимыми для работы этого состояния. 
	Это позволяет улучшить структуру компонента, уменьшить его 
	сложность и улучшить его повторное использование
'''
	},

	"su": {
		"ques": "Что делает метод shouldComponentUpdate",
		"result": 
'''
	Метод shouldComponentUpdate в React определяет, нужно 
	ли обновлять компонент при следующем рендере. Он принимает 
	пропсы и состояние компонента и возвращает true или false. 
	Если метод возвращает false, компонент не будет обновляться 
	при следующем рендере, что может повысить производительность 
	приложения.
'''
	},

	"fi": {
		"ques": "Как реализовать однократное выполнение операции при начальном рендеринге?",
		"result": 
'''
	Для выполнения операции только один раз при первоначальном 
	рендере компонента можно использовать useRef:

	import { useRef } from 'react';

	function Component() {
  		const initialRender = useRef(true);
  		if (initialRender.current) {
    		initialRender.current = false;
    		// Здесь выполняем операцию
  	}

  		return <div>Component</div>;
	}
'''
	},

	"uu": {
		"ques": "useImperativeHandle(), useLayoutEffect()",
		"result": 
'''
	-useImperativeHandle - этот хук используется для предоставления 
	доступа к методам и свойствам компонента из родительского компонента. 
	Это может быть полезно, например, для доступа к данным формы 
	из родительского компонента.

	-useLayoutEffect - этот хук вызывается после того, как компонент 
	отрисован, но до того, как он отображается на экране. Он может 
	использоваться для выполнения операций, которые должны произойти 
	после того, как компонент отрисован, например для анимации.
'''
	},

	"o": {
		"ques": "Что такое реактивность",
		"result": 
'''
	Реактивность — это свойство системы автоматически реагировать 
	на изменения во внешней среде. В программировании реактивными 
	могут быть библиотеки, языки программирования и фреймворки.

	React — это библиотека для создания пользовательских интерфейсов.
	Она не является реактивной в том смысле, что она не 
	отслеживает автоматически изменения в данных и не обновляет 
	интерфейс. Однако, React предоставляет инструменты для 
	управления состоянием и изменениями в состоянии компонентов, 
	что позволяет разработчикам создавать интерактивные 
	и динамические интерфейсы.
'''
	},

	"sf": {
		"ques": "Лучшие практики безопасности в React",
		"result": 
'''
	-Использование библиотек: Используйте известные и проверенные 
	библиотеки, такие как React Router, Redux, Material UI и т.д. 
	Это помогает предотвратить уязвимости, связанные с неправильной 
	конфигурацией и использованием компонентов.

	-Структурирование кода: Обеспечьте четкое разделение компонентов 
	на разные папки или файлы, чтобы предотвратить неправильное 
	использование или вмешательство компонентов друг в друга.

	-Валидация входных данных: Убедитесь, что все входные данные 
	проходят проверку на корректность и безопасность, прежде 
	чем они будут использоваться в приложении.

	-Изоляция состояния: Разделяйте состояние компонентов, чтобы 
	предотвратить утечки данных и проблемы с синхронизацией.

	-Защита от XSS атак: Используйте безопасные шаблоны, такие 
	как Helmet, для предотвращения XSS атак.

	-Защита CSRF атак: Применяйте CSRF токены для предотвращения 
	CSRF атак.

	-Безопасное хранение данных: Используйте надежные алгоритмы 
	шифрования и хеширования для хранения и передачи чувствительных данных.

	-Тестирование безопасности: Регулярно проводите тестирование на 
	проникновение и анализ уязвимостей, чтобы выявить и исправить 
	потенциальные проблемы безопасности.

	-Управление обновлениями: Обновляйте компоненты и библиотеки 
	своевременно для предотвращения использования уязвимостей в коде.
'''
	},

	"rx": {
		"ques": "Что такое Redux? Ключевые принципы Redux",
		"result": 
'''
	Redux — это популярная JavaScript-библиотека для управления состоянием веб-приложений. 
	Основными принципами Redux являются:

	-Единственность источника правды: В Redux есть единственное хранилище состояния, 
	в котором содержатся все данные приложения, что упрощает код и предотвращает 
	конфликты между разными источниками данных.

	-Изменение состояния с помощью чистых функций: Для изменения состояния используются 
	функции, которые не должны иметь побочных эффектов, должны быть детерминированными 
	и не должны зависеть от предыдущих вызовов.

	-Организованное управление действиями: Redux предоставляет механизм для определения 
	и передачи действий между компонентами приложения, упрощая код и делая его более понятным.
'''
	},

	"rc": {
		"ques": "Ключевые концепции Redux",
		"result": 
'''
	1.Единое состояние: В Redux имеется единственное централизованное хранилище 
	состояния, содержащее всю информацию о состоянии приложения.

	2.Чистые функции: Изменение состояния осуществляется с помощью функций, которые 
	должны быть чистыми, то есть не иметь побочных эффектов, быть детерминированными 
	(всегда возвращать одинаковый результат при одинаковых входных данных) и не 
	зависеть от предыдущих вызовов

	3.Действия: В Redux предусмотрен механизм для описания изменений состояния (действий), 
	который позволяет структурировать код и упрощает отладку.

	4.Редьюсеры: Редьюсеры — это функции, которые принимают состояние и действие и возвращают 
	новое состояние. Они используются для обновления состояния на основе полученных действий

	5.store: Магазин представляет собой обертку над состоянием и редьюсерами, которая 
	обеспечивает интерфейс для управления состоянием. Он отвечает за обработку действий, 
	вызов редьюсеров и обновление состояния.
'''
	},

	"ss": {
		"ques": "Что такое «единственный источник истины» (Single Source of Truth)",
		"result": 
'''
	Единственный источник истины” (Single Source of Truth, SST) - это принцип, 
	который гласит, что все данные должны храниться в одном централизованном месте. 
	Это позволяет избежать дублирования данных и обеспечивает согласованность информации 
	в системе. SST обычно реализуется с помощью систем управления состоянием, 
	таких как Redux или Flux.
'''
	},

	"mw": {
		"ques": "Middleware Redux",
		"result": 
'''
	Мидлвары (middlewares) — это функции, которые последовательно вызываются во время 
	обновления данных в хранилище.

	1.Сначала мидлвары встраиваются в хранилище при его создании
	2.Затем начинается отправка действий (диспатчинга)
	3.В этот момент данные проходят через мидлвары и затем попадают в редьюсер

	Благодаря такой организации программисты могут расширять библиотеки новой 
	функциональностью, не переписывая исходный код под конкретную задачу.
'''
	},

	"rd": {
		"ques": "Что такое редьюсер (Reducer)",
		"result": 
'''
	Редьюсер (reducer) - это функция в Redux, которая принимает состояние и действие 
	(действие - это изменение состояния) и возвращает новое состояние. Редьюсеры используются 
	для обновления состояния приложения на основе полученных действий.

	import { createSlice } from "@reduxjs/toolkit";

		const initialState = {
		  count: 0,
		};

		export const counterSlice = createSlice({
		  name: "counter",
		  initialState,
		  reducers: {
		    increment: (state) => {
		      state.count++;
		    },
		    decrement: (state) => {
		      if (state.count > 0) {
		        state.count--;
		      }
		    },
		  },
		});

		export const { increment, decrement } = counterSlice.actions;

		export default counterSlice.reducer;
'''
	},

	"st": {
		"ques": "Разница между React State и Redux State",
		"result": 
'''
	React state существует только на уровне одного компонента и используется для 
	хранения данных, которые изменяются внутри этого компонента. React state 
	принадлежит самому компоненту и не может быть напрямую изменено другими компонентами.

	Redux state, с другой стороны, существует на уровне всего приложения и может 
	быть изменено и использовано любыми компонентами этого приложения. Redux state 
	обычно используется для координации взаимодействия между различными компонентами 
	и обеспечения согласованности данных в приложении.
'''
	},

	"rp": {
		"ques": "Как выглядит поток данных в Redux-приложении",
		"result": 
'''
	1.Пользователь взаимодействует с компонентом.
	2.Компонент отправляет действие в хранилище состояния.
	3.Редьюсер обрабатывает действие и обновляет хранилище состояния.
	4.Хранилище состояния отправляет новые данные обратно в компонент через пропсы.
	5.Компонент обновляет свое представление на основе новых данных.
'''
	},
	"nb": {
		"ques": "Почему для архитектуры React+Redux важна иммутабельность",
		"result": 
'''
	Иммутабельность важна для архитектуры React+Redux, потому что она обеспечивает 
	предсказуемое поведение приложения и упрощает процесс разработки. Вот несколько 
	причин, почему:

	1.Оптимизация производительности: иммутабельность помогает React определить, 
	нужно ли повторно отображать компоненты, основываясь только на изменении состояния 
	Redux. Это снижает вероятность ненужных повторных рендеров и улучшает производительность 
	приложения.

	2.Упрощение отладки: когда состояние Redux иммутабельно, легче отследить изменения 
	в состоянии приложения и определить причину проблем.

	3.Улучшение тестируемости: иммутабельное состояние упрощает тестирование компонентов 
	React, так как можно изолировать их от внешних изменений и сосредоточиться на 
	проверке внутренней логики.

	4.Соблюдение принципов SOLID: иммутабельность соответствует принципу Single Responsibility 
	(SRP), который гласит, что каждый компонент должен иметь одну ответственность. В случае 
	с Redux это означает, что каждый reducer должен обрабатывать только одно изменение состояния.
'''
	},
}

