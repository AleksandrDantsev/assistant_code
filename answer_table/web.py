web = {
	"lk": {
		"ques": "Опишите весь процесс, начиная с ввода адреса сайта в адресную строку до окончания его загрузки на экране",
		"result":
'''
	1.Вы вводите адрес в строку адреса в браузере.
	2.Браузер ищет в своём кэше запись о DNS сервере соответствующего IP-адреса.

	DNS (Domain Name System) — это база данных с url-адресами сайтов и связанными 
	с ними IP. Каждый URL в интернете имеет свой уникальный IP. IP адрес принадлежит 
	компьютеру, на котором находится сервер запрашиваемого вебсайта.

	Чтобы найти запись DNS браузер проверяет 4 кэша:

	-Кэш браузера. У браузера есть хранилище DNS записей для сайтов, 
	на которых вы уже были.
	-Кэш операционной системы. Если в кэше браузера нет записи о DNS, 
	браузер делает системный запрос к операционной системе, у которой 
	есть свой кэш DNS записей.

	-Кэш роутера. Если браузер ничего не нашёл на компьютере, он делает 
	запрос к роутеру, у которого есть свой DNS кэш.

	-Кэш провайдера. Если предыдущие попытки закончились неудачей, браузер 
	обращается к кэшу провайдера.

	1.Если запрашиваемого URL нет в кэше, DNS сервер провайдера отправляет DNS запрос серверу, 
	на котором хостится необходимый вебсайт.

	DNS запрос ищет нужный IP на разных DNS серверах. Такой поиск называется рекурсивным, 
	потому что переходит от сервера к серверу, пока не найдет IP или не вернёт ошибку о 
	невозможности его найти. DNS запросы отправляют небольшие пакеты данных с информацией 
	о содержимом запроса и IP адресом, откуда это запрос пришел (IP адрес провайдера). 
	Если эти пакеты теряются, выводится ошибка. При нахождении нужного DNS сервера пакеты 
	берут верный IP адрес и возвращают его браузеру.

	1.Браузер инициализирует TCP соединение с сервером. Как только браузер получил верный 
	IP адрес, он создаёт соединение для передачи информации. В большинстве случаев браузеры 
	используют TCP протокол для любых HTTP запросов. Для соединения с сервером используется 
	процесс TCP/IP three-way handshake - трёхшаговый процесс, в котором клиент и сервер 
	обмениваются SYN (synchronize) и ACK (acknowledge) сообщениями.

	-Компьютер клиента посылает серверу SYN запрос, чтобы узнать открыт ли сервер 
	для новых соединений.
	-Если у сервера есть открытые порты для новых соединений, он отвечает пакетом SYN/ACK.
	-Клиент получает от сервера SYN/ACK пакет и подтверждает соединение, отослав ACK пакет.

	После этого TCP соединение установлено.

	1.Браузер посылает HTTP запрос к web серверу. Браузер отсылает GET запрос для 
	нужной веб страницы. Если мы отправляем форму, это будет POST запрос. Этот 
	запрос содержит дополнительную информацию о браузере (заголовок User-Agent), 
	типы запросов, которые он может принять (Accept заголовок) и заголовки соединения 
	(нужно ли сохранять соединение). Также в запросе будет информация о cookies, которые 
	браузер хранит для этого домена.

	2.Сервер обрабатывает запрос и даёт ответ. Сервер получает запрос и передаёт 
	его обработчику запросов для чтения и создания ответа. Обработчик запроса — это 
	программа (написанная на PHP, Ruby и т.д.), которая читает запрос, заголовки и 
	cookies, распознаёт, какая информация запрошена и обновляет данные на сервере, 
	если необходимо. Далее собирается ответ в определённом формате (JSON, XML, HTML).

	3.Сервер высылает HTTP ответ.

	Ответ сервера содержит запрошенную веб страницу вместе с кодом статуса, 
	типом сжатия (Content Encoding), информацией о том, как кэшировать страницу, cookies и т.д.

	В первой строчке ответа находится код статуса. Существует 5 типов:
		-1xx содержит только информационное сообщение
		-2xx указывает на успешный запрос
		-3xx переадресует клиента на другой URL
		-4xx указывает на ошибку на стороне клиента
		-5xx указывает на ошибку на стороне сервера

	Таким образом, если вы столкнулись с ошибкой, вы можете посмотреь на HTTP
	ответ и проверить код, который вы получили.

		1.Браузер отображает HTML контент.

	Браузер отображает HTML контент в несколько стадий.

	1.Рендерит HTML разметку.

	2.Проверяет HTML теги и отсылает GET запросы за дополнительными элементами 
	(изображениями, css-файлами, JavaScript и т.д.). Эти файлы браузер кэширует, 
	чтобы не скачивать их, когда вы зайдёте на этот сайт в следующий раз.
	
	3.Отображает запрошенную страницу у вас в браузере.

'''
	},
	"ki": {
		"ques": "Отличие компилятора от интерпретатора",
		"result": 
'''
	Компилятор и интерпретатор являются двумя технологиями, используемыми для 
	преобразования исходного кода программы в машинный код, который может выполняться 
	компьютером. Они оба выполняют эту функцию, но делают это разными способами.
	Компилятор читает весь исходный код программы, анализирует его и переводит в 
	машинный код. Затем этот код объединяется в один или несколько файлов, которые 
	называются объектными файлами. Объектные файлы содержат машинный код и данные, 
	необходимые для выполнения программы. После создания объектных файлов они 
	компонуются (линкуются) вместе с библиотеками и другими объектными файлами, 
	чтобы создать исполняемый файл. Этот исполняемый файл может быть запущен на 
	любом компьютере, где установлена операционная система и необходимая библиотека.
	
	Интерпретатор работает по-другому. Он считывает исходный код по одной строке 
	за раз, анализирует и выполняет его. Это означает, что программа выполняется 
	построчно, а не целиком. Интерпретатору не нужно создавать отдельный исполняемый 
	файл, так как он выполняет программу прямо в процессе интерпретации. Из-за этого 
	интерпретируемые программы могут быть запущены сразу после написания и не 
	требуют компиляции.
'''
	},

	"i": {
		"ques": "Что такое прогрессивный рендеринг",
		"result": 
'''
	Прогрессивный рендеринг - это метод визуализации веб-страниц, при котором 
	браузер начинает отображать контент страницы еще до того, как она полностью 
	загрузилась. Это позволяет пользователю видеть часть содержимого страницы 
	сразу, а не ждать, пока загрузится все.

	При прогрессивном рендеринге браузер начинает загружать и обрабатывать 
	HTML-код страницы, а затем начинает загружать и отображать изображения и 
	другие элементы. Это ускоряет загрузку страницы и делает ее более доступной 
	для пользователей.

	Одним из преимуществ прогрессивного рендеринга является то, что он позволяет 
	пользователю начать взаимодействовать с сайтом раньше, чем если бы он ждал 
	полной загрузки страницы. Это может быть особенно полезно для сайтов с большим 
	количеством изображений или видео, которые могут занимать много времени для загрузки.

	Однако, прогрессивный рендеринг также может иметь некоторые недостатки. 
	Например, если на странице есть большие изображения или видео, они могут 
	начать загружаться до того, как браузер успел обработать весь HTML-код, 
	что может привести к ошибкам в отображении страницы. Кроме того, некоторые 
	пользователи могут предпочесть дождаться полной загрузки страницы перед 
	тем, как начать ее просмотр.
'''
	},

	"p": {
		"ques": "Progressive Web Application (PWA)",
		"result": 
'''
	Progressive Web Applications (PWA) - это новый тип веб-приложений, которые сочетают 
	в себе преимущества нативных приложений и классических веб-сайтов. Они разработаны 
	с использованием современных веб-технологий, таких как Service Workers, и могут быть 
	установлены на устройство, как обычные приложения.

	PWA имеют ряд преимуществ перед нативными приложениями и обычными веб-сайтами. 
	Во-первых, они работают в любом современном браузере, без необходимости установки 
	дополнительного программного обеспечения. Во-вторых, они могут использовать возможности 
	устройства, такие как камера, микрофон, GPS и т.д., что недоступно для обычных 
	веб-сайтов. В-третьих, PWA могут работать в оффлайновом режиме, кэшируя необходимые 
	данные с помощью Service Workers.

	Разработка PWA включает в себя несколько этапов. Сначала создается обычный веб-сайт 
	с использованием HTML, CSS и JavaScript. Затем добавляются Service Workers для кэширования 
	данных и обеспечения работы в оффлайне. Наконец, добавляются дополнительные возможности, 
	такие как push-уведомления, регистрация в системе и т.д.

	В целом, PWA - это новый и перспективный подход к созданию веб-приложений, который 
	может значительно улучшить пользовательский опыт и сделать веб-технологии более 
	доступными для разработчиков и пользователей.
'''
	},

	"z": {
		"ques": "Что происходит при введение запроса в строку",
		"result": 
'''
	При вводе запроса в адресной строке браузера, запрос передаётся на сервер для обработки. 
	Сервер разбирает запрос на составляющие, такие как метод (GET, POST и т. д.), путь к ресурсу 
	и параметры запроса. Затем сервер ищет соответствующий файл (или ресурс) на своём сервере, 
	который соответствует указанному пути в запросе. Если файл найден, сервер обрабатывает его 
	и отправляет обратно браузеру в виде HTML-страницы или другого типа контента. Если файл не 
	найден, сервер возвращает ошибку.
'''
	},

	"c": {
		"ques": "Кроссбраузерность",
		"result": 
'''
	Кроссбраузерность — это свойство веб-сайта или веб-приложения отображаться и работать 
	одинаково во всех популярных браузерах. Это очень важно, потому что разные браузеры 
	имеют разные функции и возможности, и если ваш сайт не работает правильно во всех 
	браузерах, пользователи могут столкнуться с проблемами.

	Чтобы обеспечить кроссбраузерность, разработчики должны учитывать различия между 
	браузерами и использовать стандарты и технологии, которые работают во всех браузерах. 
	Это может включать в себя использование определенных функций HTML, CSS и JavaScript, 
	а также тестирование сайта в разных браузерах для проверки его работы.
'''
	},

	"pt": {
		"ques": "Чем отличаются PUT- и POST-запросы",
		"result": 
'''
	PUT - запросы приводят к замене целевого ресурса на данные, передаваемые в запросе. 
	Его можно использовать для обновления содержимого существующего ресурса или для 
	создания нового ресурса.

	POST - запросы приводят к специфической для ресурса обработке данных, передаваемых в 
	запросе. Их можно использовать для выполнения различных действий. В том числе — для 
	создания новых ресурсов, для выгрузки файлов на сервер, для отправки форм.

	Ещё одно отличие между PUT- и POST-запросами заключается в том, что PUT-запросы 
	являются идемпотентными, а POST-запросы — нет. То есть — если запрос, в котором 
	передаются одни и те же данные, и который выполняется по одному и тому же URL, 
	будет выполнен несколько раз, это равносильно однократному выполнению этого 
	запроса. Многократное выполнение POST-запроса не эквивалентно его однократному 
	выполнению. То есть — несколько таких запросов, например, могут привести к 
	созданию нескольких объектов на сервере.
'''
	},

	"o": {
		"ques": "Что такое OSI модель",
		"result": 
'''
	OSI (Open Systems Interconnection) модель - это стандарт взаимодействия открытых систем, 
	который описывает различные уровни коммуникации между двумя или более системами. OSI модель 
	состоит из семи уровней, каждый из которых имеет свои функции и задачи:

	-Физический уровень - отвечает за передачу битов данных по физическому носителю, такому 
	как кабель или оптоволокно.

	-Канальный уровень - управляет передачей данных между двумя устройствами в одной сети.

	-Сетевой уровень - отвечает за маршрутизацию пакетов данных между различными сетями 
	и устройствами.

	-Транспортный уровень - гарантирует доставку данных между двумя конечными точками, 
	такими как два компьютера.

	-Сеансовый уровень - управляет установлением, обслуживанием и завершением сеанса 
	связи между двумя системами.

	-Уровень представления - преобразует данные из одного формата в другой, чтобы они могли 
	быть прочитаны или использованы другой системой.

	-Прикладной уровень - предоставляет сервисы и приложения, которые используются пользователями 
	для доступа к данным и их обработки.
'''
	},

	"d": {
		"ques": "Поток документа",
		"result": 
'''
	Поток документа HTML - это последовательность элементов, формирующих структуру веб-страницы. 
	Каждый элемент представлен тегом, который имеет свой открывающий и закрывающий парный тег. 
	Например, тег открывает элемент, а - закрывает его. Между этими тегами находится содержимое элемента.

	Элементы могут быть вложенными, то есть один элемент может находиться внутри другого. Например, 
	элемент может содержать в себе другие элементы, такие как , и т.д.
'''
	},

	"m": {
		"ques": "Разница между адаптивным и отзывчивым дизайном",
		"result": 
'''
	Адаптивный дизайн (adaptive design) - это подход к созданию сайтов и приложений, 
	который предполагает создание нескольких вариантов дизайна для разных устройств и 
	разрешений экрана. Такой дизайн позволяет сайту или приложению выглядеть хорошо на любом 
	устройстве, но при этом может потребоваться больше времени и ресурсов на его разработку.

	Отзывчивый дизайн (responsive design) - это другой подход, который заключается в создании 
	одного универсального дизайна, который будет автоматически подстраиваться под разные 
	устройства и разрешения экрана. Такой подход требует меньше времени и ресурсов на разработку, 
	но может не обеспечить такого же качества отображения на всех устройствах, как адаптивный дизайн.
'''
	},

	"g": {
		"ques": " Разница между Progressive Enhancement и Graceful Degradation",
		"result": 
'''
	Progressive Enhancement - это подход к веб-разработке, который предполагает постепенное 
	добавление новых функций и улучшение интерфейса для современных браузеров с поддержкой JS. 
	Основная цель - предоставить базовую функциональность для старых браузеров, не поддерживающих JS, 
	чтобы пользователь мог понять основную идею сайта. Если же пользователь использует современный 
	браузер, поддерживающий JS, то ему будет предложена улучшенная функциональность.

	Graceful Degradation, напротив, направлен на предоставление основной функциональности сайта 
	даже для браузеров, не поддерживающих современные технологии. Цель этого подхода - обеспечить 
	приемлемый пользовательский опыт, даже если браузер пользователя не поддерживает последние технологии.

	Таким образом, оба подхода имеют свои плюсы и минусы, и выбор между ними 
	зависит от целей и целевой аудитории проекта.
'''
	},

	"w": {
		"ques": "Что такое Веб-компоненты и какие технологии в них используются",
		"result": 
'''
	Веб-компоненты - это элементы HTML, которые могут содержать CSS, JavaScript и другие
	ресурсы. Они позволяют создавать повторно используемые блоки, которые можно 
	использовать на разных сайтах.

	Один из примеров веб-компонентов - это тег <my-app>, который может быть 
	использован для создания приложения. Внутри этого тега можно разместить 
	любой HTML-код, CSS и JavaScript, который будет работать на всех браузерах, 
	поддерживающих веб-компоненты.

	Для создания веб-компонентов используются следующие технологии:

	-HTML - основной язык разметки для создания веб-страниц;

	-CSS - язык стилей, который позволяет задавать оформление элементов веб-страницы;

	-JavaScript - язык программирования, который используется для создания интерактивности 
	на веб-странице;

	-Shadow DOM: набор API-интерфейсов JavaScript для прикрепления инкапсулированного 
	«теневого» дерева DOM к элементу, который отображается отдельно от DOM основного 
	документа, и управления соответствующими функциями. Таким образом, вы можете сохранить
	функции элемента в секрете, поэтому для них можно создавать сценарии и стили, не 
	опасаясь коллизий с другими частями документа.
'''
	},

	"r": {
		"ques": "Что такое REST",
		"result": 
'''
	REST (Representational State Transfer) - это архитектурный стиль построения распределенных 
	программных систем. Он основан на использовании стандартных технологий, таких 
	как HTTP, URL и JSON, и не требует специфического программного обеспечения или баз данных.

	REST позволяет создавать масштабируемые, гибкие и легко обслуживаемые системы, которые 
	могут работать с большим количеством устройств и сервисов. Он также обеспечивает хорошую 
	производительность и безопасность благодаря использованию стандартных протоколов 
	и форматов данных.

	Состоит из нескольких составляющих: 

	1.Клиент-сервер
	2.StateLess - отсутствие записи состояния клиента.Запрос выполняется как в первый раз,
	сервер не сохраняет данные и запросы клиента.Каждый запрос от клиента к серверу должен 
	быть сотсавлен как в первый раз
	3.Кешируемость - сервер помечает ответ как кешируемый и данные сохраняются на стороне 
	клиента в памяти.Это позволяет снизить нагрузку на сервер, уменьшить кол-во запросов к
	серверу и быстрее отрисовывать данные клиенту.
	4.Uniform intterface - ограничения благодаря которому общение между сервером и клиентом
	становится однообразным(улучшает масштабируемость):
	-Каждый ресур должен иметь стабильный уникальный URI.Вместо 4 разных URI которые,
		удаляют, изменяют, добавляют и получают ресурс, мы используем один общи URI и 
		определенные методы:
		GET - получить данные
		POST - создание нового объекта
		PATCH - изменение всех полей объекта
		DELETE - запрос на удаление данных

	-Манипуляция ресурсом через представление - при запросе на изменение данных на 
		сервере мы отправляем не фрагмент данных которые хотим изменить, а полное представление
		данных, сервер сверяет полученные данные со своими и на основании их изменят последнии
		или оставляет их такими же(если данные одинаковы)

	-Self-descriptive message - сообщение должно содежать всю необходимую информацию

	-Гипермедиа как двигатель состояния приложения - сервер должен подсказывать клиенту какие
	шаги он может предпринять при получении ответа от сервера

	-Многоуровневость системы - между клиентом и сервером может находится дополнительный
	Proxy слой(выполняющий роль сервера когда к нему обращается клиент), клиент не занает о 
	существовании других серверов, а только о лижайшем к которому он может обращаться
'''
	},

	"f": {
		"ques": "RESTful api",
		"result": 
'''
	REST (Representational State Transfer) — это архитектурный стиль для построения распределенных 
	приложений. RESTful API — это API, которое следует принципам REST. Такие API обычно 
	используют стандартные протоколы, такие как HTTP, для обмена данными. Например, GET запрос 
	может использоваться для получения данных, POST — для создания новых ресурсов, PUT — для 
	обновления существующих и т.д.

	Кроме того, RESTful API обычно следуют принципу кеширования, что позволяет повысить 
	производительность системы. Если сервер возвращает определенный ответ на определенный запрос, 
	клиент может сохранить этот ответ и использовать его в дальнейшем, не запрашивая 
	его снова у сервера.
'''
	},

	"a": {
		"ques": "Принципы REST-архитектуры",
		"result": 
'''
	-Клиент-серверная архитектура: REST архитектура основана на клиент-серверной модели, 
	где клиенты отправляют запросы к серверу, который обрабатывает их и возвращает ответ.

	-Кеширование: RESTful API следует принципу кеширования, который позволяет сохранять 
	ответы сервера и использовать их в будущем без необходимости повторного запроса.

	-Унификация интерфейсов: REST API использует унифицированные интерфейсы, такие 
	как GET, POST, PUT, DELETE, которые позволяют клиентам взаимодействовать с ресурсами на сервере.

	-Масштабируемость: REST архитектура позволяет легко масштабировать систему, добавляя 
	новые серверы или удаляя старые без необходимости изменения кода клиента.

	-Слоизация: REST API следует принципу слоизации, который означает, что каждый уровень 
	системы выполняет свою функцию и не зависит от других уровней.

	-Стандартизация: REST использует стандартные протоколы и форматы данных, такие 
	как HTTP и JSON, что упрощает разработку и интеграцию с другими системами.

	-Слабая связанность: REST архитектура имеет слабую связанность между компонентами, что 
	обеспечивает гибкость и возможность изменения отдельных компонентов без влияния на другие.
'''
	},

	"l": {
		"ques": "Разница между layout, painting и compositing",
		"result": 
'''
	-Layout - это процесс определения размеров и положения элементов на экране. Во время 
	этого процесса браузер решает, как элементы будут располагаться на странице, и вычисляет их размеры.

	-Painting - это процесс рисования элементов на экране. Браузер берет информацию о размерах 
	и положении элементов из layout и рисует их на экране.

	-Compositing - это процесс объединения нескольких элементов в одно изображение. Во время 
	compositing браузер объединяет все нарисованные элементы в одно изображение, которое 
	затем отображается на экране.
'''
	},

	"jf": {
		"ques": "Чем отличается dev-сборник от prod",
		"result": 
'''
	- Dev-сборник (development, или dev) и prod (production) - это разные стадии 
	жизненного цикла программного обеспечения или проекта.

	- Dev-сборки обычно используются для разработки и тестирования нового функционала 
	или исправления ошибок. Они могут содержать не стабильный, не оптимизированный код, 
	который может измениться в любой момент. Dev-среды обычно доступны только для 
	разработчиков или тестировщиков проекта.

	- Prod-сборки - это финальные версии программного обеспечения, которые используются 
	в рабочей среде. Они стабильны, оптимизированы и готовы к использованию конечными 
	пользователями. Код в prod-сборках уже проверен и не должен подвергаться большим 
	изменениям.

	- В общем случае, разница между dev-сборками и prod-версиями заключается в степени 
	стабильности, оптимизации и готовности к использованию. Dev-версии предназначены 
	для разработчиков и тестировщиков, в то время как prod-версии - это финальный продукт, 
	готовый к использованию конечными пользователями.
'''
	},

	"u": {
		"ques": "Что такое Flash Of Unstyled Content (FOUC)? Как его избежать",
		"result": 
'''
	Flash Of Unstyled Content (FOUC) - это явление, при котором страница отображается 
	на некоторое время без стилей, прежде чем они загрузятся и применятся. Это может 
	произойти, когда стили загружаются асинхронно, что может привести к временному 
	“всплыванию” нестилизованного контента.

	Чтобы избежать FOUC, можно использовать следующие методы:

	-Предварительная загрузка стилей: Загружать стили заранее, чтобы они 
	были доступны при загрузке страницы.

	-Использование встроенного стиля: Добавить базовые стили во встроенный CSS, 
	чтобы контент отображался должным образом, пока загружаются основные стили.

	-Асинхронная загрузка стилей: Использовать асинхронную загрузку стилей, чтобы 
	они загружались параллельно с остальным контентом страницы.

	-Кэширование стилей: Настроить кэширование стилей, чтобы браузер мог использовать 
	ранее загруженные стили, если они не были изменены.

	-Использование CSS-препроцессоров: Использовать CSS-препроцессоры, такие как Sass 
	или Less, которые позволяют разделить стили на более мелкие части и загружать 
	их по мере необходимости.
	-Оптимизация загрузки стилей: Минимизировать количество запросов к серверу и 
	оптимизировать загрузку стилей, используя методы, такие как объединение 
	CSS, сжатие и кэширование.
'''
	},

	"h": {
		"ques": "History API в браузере",
		"result": 
'''
	History API - это инструмент, который позволяет приложениям работать с 
	историей браузера. Он позволяет получать информацию о предыдущих страницах, 
	добавлять и удалять элементы из истории, а также управлять тем, как 
	пользователь перемещается по страницам.
'''
	},

	"cm": {
		"ques": "Что такое codemod",
		"result": 
'''
	Codemod (Code Modernizer) - это инструмент, который автоматически преобразует 
	старый код в новый формат. Он позволяет разработчикам упростить процесс 
	обновления своих проектов, избавляя их от необходимости вручную изменять 
	каждый файл. Codemod работает на основе набора правил, которые определяют, 
	как должен выглядеть новый код. Например, он может преобразовывать устаревшие 
	функции в более современные, исправлять ошибки и улучшать читаемость кода.
'''
	},

	"v": {
		"ques": "Что такое веб-хранилище (web storage)",
		"result": 
'''
	Веб-хранилище - это механизм, который позволяет хранить данные на стороне 
	пользователя в браузере. Это может быть полезно для сохранения состояния 
	приложения, пользовательских настроек и другой информации. Веб-хранилище 
	доступно через JavaScript и имеет несколько различных типов, включая 
	локальное хранилище(localStorage) и сессионное хранилище(sessionStorage).
'''
	},

	"k": {
		"ques": "Разница между cookie, sessionStorage и localStorage",
		"result": 
'''
	Основное различие между cookie, sessionStorage и localStorage заключается в том, как долго они сохраняются на устройстве пользователя:

	-Cookies хранятся на устройстве до тех пор, пока пользователь не удалит их 
	вручную или не истечет срок их действия.

	-SessionStorage сохраняет данные только во время активной сессии браузера. 
	Когда пользователь закрывает браузер, все данные удаляются.

	-LocalStorage сохраняет данные на устройстве пользователя до тех пор, 
	пока они не будут удалены явно.
'''
	},

	"s": {
		"ques": "Способы уменьшения времени загрузки веб-страницы",
		"result": 
'''
	-Минификация кода: Уменьшение размера кода страницы может ускорить ее загрузку.

	-Объединение и сжатие файлов: Объединение нескольких файлов в один уменьшает 
	количество запросов к серверу.

	-Кэширование ресурсов: Если ресурсы (изображения, скрипты, стили) не меняются 
	часто, их можно закэшировать, чтобы уменьшить количество запросов к серверу.

	-Оптимизация изображений: Использование форматов изображений с меньшим размером и 
	сжатие могут уменьшить размер страницы.

	-Использование CDN (Content Delivery Network): CDN позволяет размещать ресурсы 
	ближе к пользователям, уменьшая время загрузки.

	-Отложенная загрузка ресурсов: Некоторые ресурсы могут быть не нужны сразу при
	 загрузке страницы, их можно загрузить позже с помощью асинхронных запросов.

	-Использование WebAssembly: Если на странице есть сложные вычисления, их можно 
	выполнить с помощью WebAssembly, что может уменьшить время загрузки.
'''
	},

	"x": {
		"ques": "Core Web Vitals и метрики",
		"result": 
'''
	Core Web Vitals - это набор показателей, разработанных компанией Google, для оценки производительности 
	и пользовательского опыта на сайтах. Основные метрики, входящие в Core Web Vitals, включают:


	-Largest Contentful Paint (LCP) - измеряет время, за которое на странице появляется основное содержание.

	-First Input Delay (FID) - измеряет задержку между вводом пользователя и реакцией страницы на этот ввод.

	-Cumulative Layout Shift (CLS) - оценивает стабильность макета страницы, то есть насколько часто элементы 
	 страницы перемещаются при загрузке новых ресурсов.


	Эти метрики помогают оценить производительность сайта и улучшить пользовательский опыт, 
	делая загрузку страниц быстрее и стабильнее.
'''
	},

	"x": {
		"ques": "Core Web Vitals и метрики",
		"result": 
'''
	Core Web Vitals - это набор показателей, разработанных компанией Google, для оценки производительности 
	и пользовательского опыта на сайтах. Основные метрики, входящие в Core Web Vitals, включают:


	-Largest Contentful Paint (LCP) - измеряет время, за которое на странице появляется основное содержание.

	-First Input Delay (FID) - измеряет задержку между вводом пользователя и реакцией страницы на этот ввод.

	-Cumulative Layout Shift (CLS) - оценивает стабильность макета страницы, то есть насколько часто элементы 
	 страницы перемещаются при загрузке новых ресурсов.


	Эти метрики помогают оценить производительность сайта и улучшить пользовательский опыт, 
	делая загрузку страниц быстрее и стабильнее.
'''
	},

	"j": {
		"ques": "Разница между preload, prefetch, preconnect и prerender",
		"result": 
'''
	Разница между preload, prefetch, preconnect и prerender заключается в их предназначении 
	и особенностях.

	Preload: Этот метод используется для предварительной загрузки ресурсов, таких как изображения 
	или скрипты, до того, как они понадобятся. Это помогает ускорить загрузку страницы, так как 
	ресурсы уже загружены и доступны для использования.

	Пример: <link rel=“preload” href=“image.jpg”>

	Prefetch: Prefetch используется для предварительной загрузки страниц или ресурсов, которые 
	могут быть запрошены пользователем в будущем. Это позволяет ускорить загрузку этих ресурсов, 
	когда они действительно понадобятся.

	Пример: <link rel=“prefetch” href=“page.html”>

	Preconnect: Preconnect используется для предварительного установления соединения с сервером, 
	чтобы ускорить загрузку ресурсов в будущем. Это полезно, когда ресурсы на сервере должны 
	быть загружены одновременно.

	Пример: <link rel=“preconnect” href=“https://example.com”>

	Prerender: Prerender используется для предварительной отрисовки HTML-страницы до того, как 
	она будет запрошена пользователем. Это может ускорить загрузку страницы для пользователей, 
	которые переходят на нее сразу после загрузки страницы.
'''
	},

	"e": {
		"ques": "Для чего нужен паттерн PRPL",
		"result": 
'''
	Паттерн PRPL используется в разработке веб-приложений для разделения обязанностей между 
	различными компонентами приложения. Он включает в себя следующие слои:

	-Presentation (Представление): Отвечает за отображение данных на странице и 
	взаимодействие с пользователем.

	-Routing (Маршрутизация): Обрабатывает запросы пользователя и направляет 
	их нужному компоненту.

	-Post-Processing (Пост-обработка): Выполняет бизнес-логику и обрабатывает 
	полученные данные.

	-Logic (Логика): Содержит правила и алгоритмы, определяющие, как должны 
	обрабатываться и отображаться данные.Этот паттерн помогает разделить приложение 
	на модули, что упрощает его разработку, поддержку и изменение.
'''
	},

	"t": {
		"ques": "Что такое HTTP",
		"result": 
'''
	HTTP (Hypertext Transfer Protocol) - это протокол передачи гипертекста, который 
	используется для обмена данными между веб-серверами и браузерами. Он отвечает 
	за передачу информации, такой как HTML-страницы, изображения, JavaScript и другие 
	ресурсы, необходимые для отображения веб-страниц. HTTP также используется для 
	обработки запросов от браузеров и отправки ответов обратно на них.
'''
	},

	"b": {
		"ques": "Из чего состоит HTTP-запрос",
		"result": 
'''
	HTTP-запрос состоит из трех основных частей:

	-Заголовка - содержит информацию о запросе, такую как метод запроса, 
	путь к ресурсу, версия протокола и т.д.

	-Тела - содержит данные, которые передаются на сервер или получаются 
	от него, например, текст запроса или ответ сервера.

	-Хедера - содержит метаинформацию о запросе, такую как IP-адрес
	 клиента, порт, тип контента и т.д.

	 Вот пример HTTP-запроса:

		GET /api/v1/users HTTP/1.1
		Host: api.example.com
		Authorization: Bearer <token here>
		Connection: close
		User-Agent: PostmanRuntime/7.26.8
		Accept: */*
		Cache-Control: no-cache
		Postman-Token: 04e93566-09f8-41c1-abc0-58c81f6644a0
		Host: localhost:1313
		Accept-Encoding: gzip, deflate, br
		Content-Type: application/json

		{
		    "name": "John Doe",
		    "age": 30,
		    "city": "New York"
		}

		В этом запросе метод GET используется для получения списка пользователей из 
		API с версией v1. Заголовок содержит информацию о сервере, токене авторизации 
		и т. д. Тело запроса содержит JSON-объект с информацией о пользователе.
'''
	},

	"1": {
		"ques": "Какие методы может иметь HTTP-запрос",
		"result": 
'''
	HTTP-запросы могут использовать различные методы для выполнения различных операций. 
	Вот некоторые из наиболее распространенных методов:

	-GET: Используется для получения ресурсов с сервера. Например, загрузка HTML-страницы 
	 или изображения.

	-POST: Используется для отправки данных на сервер. Например, для создания 
	 новой записи в базе данных или отправки формы.

	-PUT: Используется для обновления ресурса на сервере. Например, обновление 
	 записи в базе данных.

	-PATCH: Используется для частичного обновления ресурса на сервере.

	-DELETE: Используется для удаления ресурса на сервере.
'''
	},

	"0": {
		"ques": "Что такое HTTP cookie? Для чего они используются",
		"result": 
'''
	HTTP cookie - это небольшой фрагмент данных, который отправляется веб-сервером 
	в браузер и сохраняется на компьютере пользователя. Они используются для хранения 
	информации о пользователе, такой как настройки, предпочтения и данные для входа. 
	С помощью HTTP cookie веб-сайты могут отслеживать поведение пользователя на сайте 
	и предоставлять ему персонализированный опыт.
'''
	},

	"n": {
		"ques": "Разница между HTTP и HTTPS",
		"result": 
'''
	HTTPS - это безопасный вариант HTTP, который использует шифрование для защиты 
	данных между клиентом и сервером. Он обеспечивает большую безопасность, чем 
	обычный HTTP, так как данные передаются в зашифрованном виде и защищены от 
	перехвата. Кроме того, HTTPS часто ассоциируется с сертификатами безопасности, 
	которые подтверждают подлинность сайта и защищают от man-in-the-middle атак.
'''
	},

	"t2": {
		"ques": "Разница между HTTP/1 и HTTP/2",
		"result": 
'''
	HTTP/2 — более новый и продвинутый протокол по сравнению с HTTP. Вот основные различия между ними:

	-Производительность: HTTP/2 предлагает лучшую производительность благодаря поддержке 
	мультиплексирования и сжатия, что позволяет загружать страницы быстрее и уменьшает 
	время ответа сервера.

	-Шифрование: HTTP/2 поддерживает шифрование по умолчанию, что обеспечивает безопасность 
	передачи данных и защиту от перехвата информации.

	-Совместимость с браузерами: Большинство современных браузеров поддерживают HTTP/2, 
	но не все поддерживают HTTP.

	-Поддержка сервера: Не все серверы поддерживают HTTP/2, поэтому может потребоваться обновление 
	программного обеспечения сервера для использования этого протокола.
'''
	},

	"w2": {
		"ques": "Как работает мультиплексирование в HTTP/2",
		"result": 
'''
	Мультиплексирование - это механизм, который позволяет передавать несколько 
	потоков данных через одно соединение. В HTTP/2 мультиплексирование работает 
	путем разделения соединения на несколько логических каналов, каждый из которых 
	может передавать свой поток данных. Это позволяет увеличить пропускную способность 
	и снизить задержки при передаче данных.
'''
	},

	"ts": {
		"ques": "Что такое “трехстороннее рукопожатие” (Triple handshake)",
		"result": 
'''
	“Тройное рукопожатие” (Triple handshake) - это процесс установления безопасного 
	соединения между клиентом и сервером в протоколе HTTPS. Этот процесс включает в себя три этапа:

	1.Клиент отправляет запрос на установление соединения, указывая в нем, что он поддерживает 
	протокол TLS (Transport Layer Security).

	2.Сервер отвечает на запрос, подтверждая, что он также поддерживает TLS, и предлагает список 
	доступных алгоритмов шифрования.

	3.Клиент выбирает один из предложенных алгоритмов и отправляет подтверждение серверу. После 
	этого устанавливается безопасное соединение и начинается передача данных.
'''
	},

	"pu": {
		"ques": "Разница между PUT и POST-запросами",
		"result": 
'''
	PUT и POST являются методами HTTP, используемыми для отправки запросов на сервер. 

	Вот основные различия между ними:

	-Цель: PUT используется для обновления ресурсов, а POST - для создания новых ресурсов.

	-Синтаксис: PUT требует указания полного URI ресурса, в то время как POST использует 
	тело запроса для передачи данных.

	-Безопасность: PUT более безопасен, так как он проверяет, существует ли уже ресурс, 
	прежде чем пытаться его обновить. POST не делает такой проверки и может привести к 
	дублированию или другим ошибкам, если не используется должным образом
'''
	},

	"d2": {
		"ques": "Разница между протоколами TCP и UDP",
		"result": 
'''
	Протоколы TCP и UDP являются двумя основными протоколами транспортного уровня в интернет-стеке.
	Они используются для передачи данных между компьютерами в сети и обеспечивают надежную 
	связь и доставку данных.

	-TCP (Transmission Control Protocol) - это потоковый протокол, который обеспечивает 
	надежную передачу данных между двумя точками. Он гарантирует надежность и порядок доставки 
	пакетов, а также контролирует их количество, устанавливая соединения между двумя конечными 
	точками. TCP использует механизм “трехстороннего квитирования” (handshake) для установления 
	и поддержания соединений, а также для контроля корректности передачи данных. Этот протокол 
	обычно используется для соединений, требующих надежной и постоянной связи, таких как 
	веб-браузинг, электронная почта, FTP и т.д.

	-UDP (User Datagram Protocol) - является дейтаграммным протоколом, который не гарантирует 
	надежную доставку пакетов, но обеспечивает более быструю передачу данных. UDP не устанавливает 
	соединения, и каждый пакет передается как независимая дейтаграмма. Он не контролирует 
	порядок или количество переданных пакетов, и доставка данных зависит от работы IP-уровня. 
	UDP обычно используется для приложений, где надежность не критична, а требуется высокая 
	скорость передачи данных, таких как потоковое видео, онлайн-игры, VoIP и т. д.
'''
	},

	"ws": {
		"ques": "Что такое WebSocket",
		"result": 
'''
	WebSocket - это протокол связи, предназначенный для обеспечения двусторонней связи между 
	веб-клиентом и сервером. Он позволяет создавать соединение между клиентом и сервером, 
	которое остается открытым даже после первоначального запроса, что позволяет осуществлять 
	обмен данными в реальном времени.

	Принцип работы WebSocket заключается в следующем:

	1.Клиент открывает соединение с сервером на порт 80 (HTTP) или 443 (HTTPS).

	2.Сервер отвечает на запрос клиента и открывает со своей стороны соединение с клиентом.

	3.После того, как соединение установлено, клиент и сервер могут обмениваться данными в 
	дуплексном режиме, то есть в обе стороны одновременно.

	4.Данные передаются в виде текстовых сообщений, но могут быть преобразованы в любой 
	другой формат с помощью соответствующего протокола.

	5.Когда одна из сторон закрывает соединение, другая сторона получает уведомление об 
	этом и может закрыть свое соединение.

	6.WebSocket используется в различных приложениях, таких как чаты, онлайн-трансляции, 
	игры и т.д., где требуется обмен данными в режиме реального времени.
'''
	},

	"ws": {
		"ques": "Что такое WebSocket",
		"result": 
'''
	WebSocket - это протокол связи, предназначенный для обеспечения двусторонней связи между 
	веб-клиентом и сервером. Он позволяет создавать соединение между клиентом и сервером, 
	которое остается открытым даже после первоначального запроса, что позволяет осуществлять 
	обмен данными в реальном времени.

	Принцип работы WebSocket заключается в следующем:

	1.Клиент открывает соединение с сервером на порт 80 (HTTP) или 443 (HTTPS).

	2.Сервер отвечает на запрос клиента и открывает со своей стороны соединение с клиентом.

	3.После того, как соединение установлено, клиент и сервер могут обмениваться данными в 
	дуплексном режиме, то есть в обе стороны одновременно.

	4.Данные передаются в виде текстовых сообщений, но могут быть преобразованы в любой 
	другой формат с помощью соответствующего протокола.

	5.Когда одна из сторон закрывает соединение, другая сторона получает уведомление об 
	этом и может закрыть свое соединение.

	6.WebSocket используется в различных приложениях, таких как чаты, онлайн-трансляции, 
	игры и т.д., где требуется обмен данными в режиме реального времени.
'''
	},

	"dt": {
		"ques": "Разница между Long-Polling, Websockets и Server-Sent Events",
		"result": 
'''
	Long-polling, WebSockets и Server-sent events - это различные технологии, используемые 
	для создания интерактивных веб-приложений и веб-сервисов. Вот основные различия между ними:

	Long-polling: Long-polling - это метод, при котором клиентский запрос (запрос на обновление 
	данных) остается активным до тех пор, пока сервер не будет готов ответить. Таким образом, 
	клиент может получать обновления с сервера с большей частотой и меньшим количеством запросов.
	Однако, этот метод может приводить к перегрузке сервера, если слишком много клиентов 
	используют его одновременно. Кроме того, long-polling не всегда совместим со всеми браузерами.

	WebSockets: WebSockets - это протокол, который позволяет двум сторонам (клиенту и серверу) 
	поддерживать постоянное соединение и обмениваться данными в обе стороны. Это означает, что 
	сервер может отправлять данные клиенту, а клиент может отправлять данные серверу в любое 
	время. WebSockets обеспечивают более высокую производительность и масштабируемость, чем 
	long-polling. Однако, они требуют поддержки со стороны браузера и сервера, что может 
	ограничивать их использование.

	Server-sent events: Server-sent events (SSE) - это механизм, который позволяет 
	серверу отправлять события клиенту без необходимости получения запроса от клиента. 
	Это может быть полезно для обновления данных в реальном времени, например, для отображения 
	последних новостей или обновлений статуса. SSE более эффективны, чем long-polling, но 
	менее эффективны, чем WebSockets, так как они не поддерживают двусторонний обмен данными.

	В целом, выбор между long-polling, WebSockets и SSE зависит от требований вашего 
	приложения. Если вам нужна высокая производительность и поддержка двустороннего обмена 
	данными, то WebSockets могут быть лучшим выбором. Если же вам нужно обновлять данные в 
	реальном времени без необходимости двустороннего обмена, то SSE могут быть более 
	подходящим выбором. Long-polling может быть хорошим выбором, если вам нужна более 
	низкая нагрузка на сервер, но он может не быть доступен во всех браузерах.
'''
	},

	"jp": {
		"ques": "Как работает JSONP",
		"result": 
'''
	JSONP — это метод, который позволяет веб-страницам, загруженным с одного домена, 
	получать данные с другого домена. Это достигается путем вставки кода JavaScript в 
	страницу, которая делает запрос на удаленный сервер.

	Когда страница загружает JSONP-ресурс, сервер отправляет обратно не обычный JSON, а 
	JSON-объект, обернутый в функцию. Эта функция вызывается автоматически, когда страница
	 загружает ресурс, и ее результатом является выполнение кода JavaScript.

	Например, если страница делает запрос на получение списка пользователей, сервер 
	может отправить обратно следующий ответ:

		callbackFunc([
		  {
		    "name": "Alice",
		    "age": 20
		  },
		  {
		    "name": "Bob",
		    "age": 21
		  }
		]);

	Здесь функция callbackFunc будет вызвана с массивом пользователей в качестве 
	аргумента. Функция может затем выполнить любой необходимый код, например, добавить 
	пользователей в список или отобразить их информацию.

	Однако стоит отметить, что JSONP может нарушать правила безопасности, поскольку 
	позволяет страницам с одного домена получать доступ к данным с другого домена 
	без прямого разрешения.
'''
	},

	"in": {
		"ques": "Что такое IndexedDB в браузере? Преимущества IndexedDB",
		"result": 
'''
	IndexedDB — это API, предоставляемый браузерами для хранения структурированных данных на 
	стороне клиента. Он обеспечивает более быстрое и эффективное хранение данных по 
	сравнению с локальным хранилищем (localStorage) и позволяет работать с большими объемами данных.

	Преимущества IndexedDB включают:

	-Большой объем хранилища: IndexedDB позволяет хранить до 25 объектов, каждый из которых 
	может иметь размер до 10 МБ. Это значительно больше, чем локальное хранилище, которое 
	ограничено 5 МБ на домен.

	-Структурированные данные: В отличие от локального хранилища, данные в IndexedDB хранятся 
	в виде объектов, что облегчает их обработку и извлечение.

	-Быстрый доступ к данным: IndexedDB использует индексы для быстрого поиска данных, что 
	делает его более эффективным, чем локальное хранилище.

	-Поддержка асинхронного режима: IndexedDB поддерживает асинхронный режим, что позволяет 
	разработчикам выполнять другие задачи во время загрузки и сохранения данных.

	Тем не менее, следует помнить, что использование IndexedDB может снизить производительность 
	браузера, особенно на старых устройствах. Поэтому перед использованием этого API следует 
	оценить требования к приложению и выбрать наиболее подходящий вариант хранения данных
'''
	},

	"sw": {
		"ques": "Что такое Service Workers",
		"result": 
'''
	Service Workers – это специальные программы, которые работают в фоне и выполняют 
	различные задачи, связанные с улучшением пользовательского опыта. Например, они 
	могут кэшировать данные, обрабатывать push-уведомления, управлять доступом к сети 
	и многое другое.

	Service Workers работают на уровне браузера и не влияют на основной процесс 
	выполнения JavaScript-программы. Они могут быть активированы в любое время и 
	выполнять свои задачи, не мешая основной программе.
'''
	},

	"ww": {
		"ques": "Что такое Web Workers",
		"result": 
'''
	Web Workers - это технология, которая позволяет выполнять JavaScript-код в 
	отдельном потоке, не блокируя основной поток пользовательского интерфейса. 
	Это может быть полезно, например, для выполнения длинных операций или для 
	обработки большого количества данных. Web Workers создаются с помощью объекта 
	Worker, который принимает код JavaScript, который нужно выполнить, и создает 
	новый поток для его выполнения.
'''
	},


	"w5": {
		"ques": "Что такое Web Worklet",
		"result": 
'''
	Web Worklet - это новая технология, которая позволяет использовать нативные 
	функции операционной системы в веб-приложениях. Она позволяет использовать 
	функции, которые обычно доступны только в нативных приложениях, в веб-приложениях. 
	Например, можно использовать функции графического процессора для обработки изображений 
	или функции аудио API для работы с аудио. Web Worklet также позволяет использовать 
	нативные шрифты в веб-приложениях, что может улучшить внешний вид сайта.
'''
	},

	"dd": {
		"ques": "Механизм установки сеанса между клиентом и сервером",
		"result": 
'''
	Для установки сеанса между клиентом и сервером используется следующий механизм:

	1.Клиент отправляет запрос на сервер с указанием необходимых данных для установки сессии, 
	например, имени пользователя и пароля.

	2.Сервер проверяет правильность этих данных и, если они верны, генерирует уникальный 
	идентификатор сессии (session ID).

	3.Сервер сохраняет этот ID в своей базе данных и отправляет его обратно клиенту.
	4.Клиент сохраняет полученный ID в cookie-файле своего браузера.

	5.При последующих запросах к серверу клиент отправляет этот ID вместе с запросом.
	6.Сервер, получив ID сессии, проверяет его наличие в своей базе данных, и если все верно, 
	продолжает обработку запроса.

	7.В конце сессии клиент удаляет cookie с ID, и сессия завершается.

	8.Этот механизм позволяет серверу отслеживать активность пользователя в течение его 
	сессии и обеспечивает безопасность, так как только клиент с правильным ID может 
	получить доступ к данным.
'''
	},

	"ap": {
		"ques": "Что Такое API",
		"result": 
'''
	API (Application Programming Interface) - это набор правил и процедур, которые 
	позволяют разным программам взаимодействовать друг с другом. Он определяет, каким 
	образом одна программа может получить доступ к функциям другой программы.

	API могут быть как открытыми, так и проприетарными. Открытые API доступны для 
	использования всеми желающими, а проприетарные - только для пользователей конкретной 
	программы или сервиса.

	Одним из самых известных примеров API является Microsoft Office API, который позволяет 
	разработчикам создавать программы, работающие с документами Microsoft Office
'''
	},

	"cd": {
		"ques": "Что такое CDN",
		"result": 
'''
	CDN (Content Delivery Network) - это сеть серверов, расположенных в разных 
	точках мира, которые используются для быстрой доставки контента пользователям. 
	Когда пользователь запрашивает страницу или файл, CDN определяет, где находится 
	ближайший сервер с копией этого контента, и перенаправляет запрос на этот сервер. 
	Это ускоряет загрузку страниц и файлов, так как пользователю не приходится ждать, 
	пока запрос дойдет до удаленного сервера и вернется обратно.
'''
	},

	"ip": {
		"ques": " Что такое IP-адрес",
		"result": 
'''
	IP-адрес (Internet Protocol Address) - это уникальный числовой идентификатор, 
	присваиваемый каждой единице оборудования, подключаемой к компьютерной сети, 
	работающей по протоколу IP. Этот протокол обеспечивает передачу данных между 
	компьютерами в сети и отвечает за маршрутизацию пакетов данных к их конечному получателю.

	IP-адрес состоит из двух частей: адреса сети и адреса узла (хоста) в этой сети. 
	Адрес сети определяет местоположение этой сети в глобальной интернет-архитектуре, 
	а адрес узла идентифицирует устройство (компьютер, сервер, маршрутизатор) внутри этой сети.

	Адрес узла обычно представлен в виде четырех десятичных чисел (от 0 до 255), разделенных точками. 
	Например, IP-адрес 192.168.1.100 обозначает адрес узла 100 в сети 192.168.1. Числа после точек 
	также называются октетами или байтами.

	Диапазон возможных IP-адресов ограничен, поэтому для увеличения количества доступных адресов 
	используются маски подсети и технологии, такие как бесклассовая междоменная маршрутизация (CIDR).
'''
	},

	"hd": {
		"ques": "Разница между host и domain",
		"result": 
'''
	Host - это устройство, подключенное к сети, например компьютер, сервер или другое устройство. 
	Host имеет уникальный IP адрес, который позволяет другим устройствам находить его в сети. 
	Host может иметь несколько IP адресов, если он подключен к нескольким сетям.

	Domain - это имя, которое указывает на хост в интернете. Domain может быть зарегистрирован 
	в системе доменных имен (DNS), которая переводит доменные имена в IP адреса. Domain может 
	указывать на один хост или на несколько хостов, в зависимости от настроек DNS.

	Разница между host и domain заключается в том, что host - это физическое устройство, а 
	domain - это просто имя, которое указывает на это устройство. Host имеет уникальные IP 
	адреса, а domain может указывать на несколько хостов с разными IP адресами.
'''
	},

	"ur": {
		"ques": "Разница между URI и URL",
		"result":
'''
	URI (Uniform Resource Identifiers) и URL (Uniform Resource Locators) оба являются 
	идентификаторами ресурсов, но они отличаются друг от друга.

	URI может идентифицировать ресурсы, которые находятся на веб-сайте, файлы на компьютере, 
	изображения в галерее и т.д. Он может быть абсолютным, начинающимся с протокола (например, http:// или ftp://) 
	и заканчивающимся именем ресурса (например, https://example.com/index.html), или относительным, начинающимся 
	с идентификатора ресурса (например, #contact или …/images) и заканчивающимся на имя ресурса.

	С другой стороны, URL является частным случаем URI и используется для идентификации ресурсов, 
	доступных через интернет. Он всегда начинается с протокола (обычно http:// или https://), затем 
	следует доменное имя сайта и путь к ресурсу, например http://example.com/path/to/resource. 
	Файлы на компьютере или изображения в галерее не могут быть идентифицированы с помощью URL.
'''
	},

	"ur": {
		"ques": "Разница между URI и URL",
		"result":
'''
	URI (Uniform Resource Identifiers) и URL (Uniform Resource Locators) оба являются 
	идентификаторами ресурсов, но они отличаются друг от друга.

	URI может идентифицировать ресурсы, которые находятся на веб-сайте, файлы на компьютере, 
	изображения в галерее и т.д. Он может быть абсолютным, начинающимся с протокола (например, http:// или ftp://) 
	и заканчивающимся именем ресурса (например, https://example.com/index.html), или относительным, начинающимся 
	с идентификатора ресурса (например, #contact или …/images) и заканчивающимся на имя ресурса.

	С другой стороны, URL является частным случаем URI и используется для идентификации ресурсов, 
	доступных через интернет. Он всегда начинается с протокола (обычно http:// или https://), затем 
	следует доменное имя сайта и путь к ресурсу, например http://example.com/path/to/resource. 
	Файлы на компьютере или изображения в галерее не могут быть идентифицированы с помощью URL.
'''
	},

	"qq": {
		"ques": "Разница между монолитной и микросервисной архитектурами",
		"result":
'''
	Монолитная архитектура предполагает, что все компоненты приложения находятся в одном 
	большом блоке (монолите). Это означает, что все функции и возможности приложения находятся 
	в одном месте. Монолитные приложения обычно проще в разработке и обслуживании, так как 
	все компоненты находятся в одном месте и доступны для изменения. Однако, с увеличением 
	размера приложения, монолитная архитектура может стать сложной для поддержки и масштабирования.

	Микросервисная архитектура, с другой стороны, предполагает разделение приложения на множество 
	мелких сервисов. Каждый сервис выполняет свою функцию и взаимодействует с другими сервисами 
	через API. Микросервисная архитектура позволяет более гибко масштабировать приложение, так 
	как можно увеличивать или уменьшать количество серверов в зависимости от нагрузки на каждый 
	сервис. Кроме того, микросервисы могут быть разработаны и протестированы независимо друг от 
	друга, что упрощает процесс разработки. Однако микросервисная архитектура может быть сложнее 
	в настройке и поддержке из-за большого количества компонентов и зависимостей между ними.
'''
	},

	"sv": {
		"ques": "Опишите способы оптимизации SVG-файлов",
		"result":
'''
	1.Оптимизация SVG-файлов может включать в себя следующие способы:

	2.Сжатие данных: Используйте gzip-сжатие для уменьшения размера файла.
	
	3.Удаление неиспользуемых элементов: Удалите все ненужные элементы, 
	такие как комментарии, пробелы и т.д.

	4.Минимизация атрибутов: Минимизируйте количество атрибутов, используя 
	короткие названия и значения.

	5.Слияние групп: Слейте несколько элементов в одну группу для уменьшения 
	количества объектов.

	6.Оптимизация путей: Используйте короткие и простые пути для уменьшения 
	размера файла.

	7.Использование векторных изображений: SVG-файлы могут быть очень большими, 
	поэтому используйте векторные изображения, если это возможно.
'''
	},
	"dw": {
		"ques": "Сколько ресурсов браузер может одновременно загружать с одного домена",
		"result":
'''
	Современные браузеры обычно поддерживают шесть одновременных соединений и 
	параллельных загрузок.
'''
	},
	"bv": {
		"ques": "Что такое CORS",
		"result": 
'''
	CORS (Cross-Origin Resource Sharing) - механизм, который дает возможность 
	клиенту (агенту) получать разрешение на доступ к ресурсам сервера на домене, 
	который отличается о того, который использует сайт. Механизм использует дополнительные 
	HTTP-заголовки. Если источник документа, с которого происходит запрос на ресурс, 
	отличается от ресурса протоколом, доменом или портом, то считается, что агент делает 
	запрос с другого источника. Т.е. происходит cross-origin HTTP request.
'''
	},
	"gg": {
		"ques": "Для чего нужен CORS",
		"result": 
'''
	Браузеры ограничивают запросы с другого источника (cross-origin запросы) в 
	целях безопасности. Такие запросы могут совершать, например, сторонние скрипты,
	подключенные на сайт. Такие API как Fetch или XMLHttpRequest следуют политике 
	одного источника (same-origin policy). Таким образом, при использовании web-приложением 
	этого API, существует ограничение: домен запрошенных HTTP-ресурсов и домен web-приложения 
	должен быть одним и тем же. Для снятия этого ограничения нужно использовать CORS-заголовки.
'''
	},
	"cc": {
		"ques": "Что такое HTTP cookie",
		"result": 
'''
	HTTP cookie (куки) - это небольшой фрагмент данных, который отправляется сервером 
	в браузер пользователя. Далее браузер может сохранить cookie и отправлять обратно 
	серверу с каждым запросом. Такой механизм позволяет узнать, с одного и того же 
	браузера были отправлены запросы или нет. Это используется, например, для 
	аутентификации пользователя.
'''
	},
	"ew": {
		"ques": "feature detection, feature inference и user-agent",
		"result": 
'''
	Разница заключается в методах определения возможностей браузера:
	1.Feature detection — прямое определение наличия определённой функции или 
	возможности в браузере. Например, проверка существования объекта XMLHttpRequest.

	2.Feature inference — предполагает наличие определённой функции или возможности 
	на основе наличия других связанных функций. Например, если существует функция 
	localStorage, предполагается, что также доступна функция sessionStorage.

	3.Анализ строки user-agent — метод, основанный на информации, отправляемой браузером, 
	но он считается устаревшим и менее надёжным, так как требует постоянных обновлений для 
	адаптации к новым браузерам и функциям
'''
	},
}

